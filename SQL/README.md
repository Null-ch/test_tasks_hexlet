
<details>
<summary>1. Создание таблиц (createTables.sql)</summary>

Напишите запрос, создающий таблицу courses со следующими полями:

name типа varchar длиной 255.
body типа text.
created_at типа timestamp.
Напишите запрос, создающий таблицу users со следующими полями:

first_name типа varchar длиной 255.
email типа varchar длиной 255.
manager типа boolean.
Напишите запрос, создающий таблицу course_members со следующими полями:

user_id типа bigint
course_id типа bigint
created_at типа timestamp

</details>

<details>
<summary>2. Вставка и модификация (insertionAndModification.sql)</summary>
Запишите в файл следующие запросы:

Запрос, который удаляет пользователя с именем Sansa
Запрос, который вставляет в базу пользователя с именем Arya и почтой arya@winter.com
Запрос, который устанавливает флаг manager в true для пользователя с емейлом tirion@got.com
Подсказки:

Перед тем как писать запросы в файл, зайдите в psql и поэкспериментируйте как следует
Не бойтесь сломать что-то в базе, всегда можно восстановиться командой make reset в терминале
Структуру базы данных можно подсмотреть в файле init.sql
</details>

<details>
<summary>3. Выборка данных (Selection.sql)</summary>
Составьте запрос, который извлекает все записи из таблицы users по следующим правилам:
* Пользователи должны быть рождены позже 23 октября 1999 года. Поле `birthday`.
* Выборка отсортирована в алфавитном порядке по полю `first_name`
* Нужно извлечь только три записи
</details>
  
</details>

<details>
<summary>4. Practice (createTables.sql)</summary>
-- Создайте таблицу users со следующими полями:
--     id - первичный ключ
--     first_name - имя
--     created_at - дата создания пользователя
-- Добавьте в таблицу users одну произвольную запись.
-- Создайте таблицу orders со следующими полями:
--     id - первичный ключ
--     user_first_name - при вставке записи здесь указывается имя пользователя из таблицы users
--     months - количество покупаемых месяцев (обучение на Хекслете)
--     created_at - дата создания заказа
-- Добавьте в таблицу orders два заказа на созданного ранее пользователя
</details>

<details>
<summary>5. Первая нормальная форма (theFirstNormalForm.sql)</summary>
Создайте таблицу users со следующими полями:
id - первичный ключ
first_name - имя
created_at - дата создания пользователя
Добавьте в таблицу users одну запись с именем пользователя Tom.
Создайте таблицу orders со следующими полями:
id - первичный ключ
user_first_name - при вставке записи здесь указывается имя пользователя из таблицы users
months - количество покупаемых месяцев (обучение на Хекслете)
created_at - дата создания заказа
Добавьте в таблицу orders два заказа на созданного ранее пользователя
Значения первичных ключей задайте самостоятельно. Автогенерация изучается дальше по курсу. Примеры вставки данных в эти таблицы:
</details>


<details>
<summary>6. Вторая нормальная форма (secondNormalForm.sql)</summary>
-- Создайте две таблицы cars и brands, в которых отобразите нормализованную структуру таблицы old_cars.
-- Создайте суррогатный первичный ключ для каждой из таблиц. Не забудьте указать внешний ключ в таблице
-- cars на таблицу brands. Поле, с именем brand в таблице old_cars, должно иметь название name в таблице brands.
-- Добавьте в эти таблицы те же записи, что и в исходной таблице, но в нормализованной форме.
</details>

<details>
<summary>7. Третья нормальная форма (thirdNormalForm.sql)</summary>
 -- В базе данных содержится таблица old_cities, следующей структуры

-- country	region	city
-- Россия	Татарстан	Бугульма
-- Россия	Татарстан	Казань
-- Россия	Самарская область	Тольятти
-- Город в этой таблице зависит и от региона и от страны. Зависимость от региона прямая, а вот от
-- страны город зависит косвенно, так как страна определяется регионом.

-- solution.sql
-- Создайте три таблицы countries, country_regions и country_region_cities, в которых отобразите
-- нормализованную структуру исходной таблицы old_cities. Создайте суррогатный первичный ключ для каждой
-- из таблиц. Не забудьте указать внешний ключ. Поле для имени сущности в каждой таблице назовите именем name.
-- Все ключи должны иметь тип bigint.
-- Добавьте в созданные таблицы те же записи, что и в исходной таблице, но в нормализованной форме.
-- Подсказки
-- Внешний ключ именуется как: имя таблицы в единственном числе плюс _id.
</details>

<details>
<summary>8. Автоинкримент (autoinc.sql)</summary>
-- solution.sql
-- Создайте таблицу article_categories с двумя полями:

-- id - автогенерируемый первичный ключ
-- name - текстовое поле
-- Добавьте в эту таблицу две произвольные записи
</details>

<details>
<summary>9. Онтология (ontology.sql)</summary>
-- Каждый раз когда мы совершаем покупки в интернете, на стороне продавца формируется "заказ". Это сущность,
-- которая описывает собой конкретную покупку и включает в себя пользователя, а также список позиций.
-- Если взять какой-нибудь интернет-магазин торгующий электроникой, то в заказ могут входить клавиатура,
-- мышка и коврик. Ниже представлена ERD в которой отражены сущности, участвующие в процессе.
</details>

<details>
<summary>10. Ограничения (limit.sql)</summary>
-- Составьте запрос, который извлекает все записи из таблицы users по следующим правилам:
-- Пользователи должны быть рождены (birthday) раньше 3 октября 2002 года.
-- Данные отсортированы по имени в прямом порядке
-- Нужно извлечь 3 строчки, пропустив первые две
</details>

<details>
<summary>11. Alter (alter.sql)</summary>
-- Напишите запрос обновляющий таблицу структуры:

CREATE TABLE users (
    id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    email varchar(255) NOT NULL,
    age integer,
    name varchar(255)
);
-- В структуру:

CREATE TABLE users (
    id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    email varchar(255) NOT NULL UNIQUE,
    first_name varchar(255) NOT NULL,
    created_at timestamp
);
-- name и first_name - одна и та же колонка.
</details>

<details>
<summary>12. Order (order.sql)</summary>
-- Составьте запрос, который извлекает из базы данных (таблица users) все имена (поле first_name)
-- пользователей, отсортированных по дате рождения (поле birthday) в обратном порядке. Те записи,
-- у которых нет даты рождения, должны быть в конце списка.
</details>

<details>
<summary>13. Where (where.sql)</summary>
-- Составьте запрос, который извлекает все записи из таблицы users по следующим правилам:

-- Пользователи созданы позже 2018-11-23 (включая эту дату) и раньше 2018-12-12 (включая эту дату)
-- или поле house имеет значение stark
-- Данные отсортированы по дате создания по убыванию
</details>

<details>
<summary>14. Limit (limit.sql)</summary>
-- Составьте запрос, который извлекает все записи из таблицы users по следующим правилам:

-- Пользователи должны быть рождены (birthday) раньше 3 октября 2002 года.
-- Данные отсортированы по имени в прямом порядке
-- Нужно извлечь 3 строчки, пропустив первые две
</details>

<details>
<summary>15. Distinct (distinct.sql)</summary>
-- Составьте запрос, который извлекает из таблицы users все уникальные значения поля house
-- отсортированные по возрастанию.
</details>

<details>
<summary>16. Функции (func.sql)</summary>
-- Составьте запрос, который извлекает из таблицы users количество записей, у которых значение поля house равно stark.
</details>

<details>
<summary>17. Группировка (group.sql)</summary>
-- Составьте запрос (к таблице users), который считает количество пользователей, рождённых (поле birthday)
-- в каждом году (из тех, что есть в birthday) по следующим правилам:

-- Анализируются только те пользователи, у которых указан год рождения.
-- Выборка отсортирована по году рождения в прямом порядке.
-- Подсказки
-- Чтобы извлечь год из дня рождения, воспользуйтесь конструкцией: EXTRACT(year FROM birthday)
-- AS year_of_birthday.
-- Итоговая таблица должна иметь два поля с именами year_of_birthday и count.
</details>

<details>
<summary>18. Соединение (join.sql)</summary>
-- Составьте запрос, который извлекает из базы идентификатор топика и имя автора топика (first_name)
-- по следующим правилам:

-- Анализируются топики только тех пользователей, чей емейл находится на домене lannister.com
-- Выборка отсортирована по дате создания топика в прямом порядке
</details>

<details>
<summary>19. Выборка данных (transaction.sql)</summary>
-- Механизм дружбы в социальных сетях, обычно, реализуется через отдельную таблицу friendship ссылающуюся
-- на обоих пользователей. Когда два человека начинают дружить, то в эту таблицу заносятся сразу две записи:

-- friendship

-- id	user1_id	user2_id
--  1	       3	10
--  2	      10	3
-- Такой способ организации данных позволяет работать с понятием "дружба" независимо от того,
-- кто был указан первым, а кто вторым.

-- solution.sql
-- Составьте транзакцию, которая создает дружбу между пользователями Tirion и Jon.
</details>
